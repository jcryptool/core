Constants_10=Double and Add
Constants_100=x + 
Constants_101=\n   GF(
Constants_102=), a = 
Constants_103=, b = 
Constants_104=\n   Initialer EC-Punkt P: 
Constants_105=\n   Parameter k: 
Constants_106=\n   k in Binärform: 
Constants_107=\n\nRandomisierung:\n   
Constants_108=Zufälliger Faktor r = 
Constants_109=\n   a' = a*r\u2074 = 
Constants_11=Double and Add Always:\nDieser Algorithmus fürt eine "Dummy"-Berechnung ein. Es wird nach jeder Multiplikation addiert, auch wenn dies nicht für die Berechnung nötig ist. Das Ergebnis nach der Addition wird verworfen und mit dem voherigen Ergebnis weiter gerechnet. Die Dummy-Operation schützt vor SPA-Attacken; jedoch nicht gegen DPA-Attacken, da durch differentielle Analysen weiterhin der private Schlüssel extrahiert werden kann.
Constants_110=, b' = b*r\u2076 = 
Constants_111=\n   P' = (r²*Xp, r³*Yp) = (
Constants_112=\n   EC': y² = x³ + a'x + b' 
Constants_113=\n            = x³ + 
Constants_114=x + 
Constants_115=. höchstes Bit: 
Constants_116=Q := 2Q = 
Constants_117=P = (
Constants_118=Q := Q + P = 
Constants_12=Zufälliger Parameter k:\nDer Faktor k, mit dem der Punkt P multipliziert wird, wird bei jeder Ausführung neu randomisiert. Dadurch kann ein Angreifer nicht mehr den privaten Schlüssel berechnen, indem er mehrere Messreihen vergleicht.\n\nDas Prinzip ist folgendermaßen:\nZuerst wird ein zufälliger Wert zwischen 1 und p - 1 gewählt. Dann wird k durch folgende Formel randomisiert: k' = k + r*ord(P).\nDa ord(P)*P der Punkt im Unendlichen ist, ergibt sich:\nG' =\n(k+r*ord(P))*P =\nk*P+r*(oder(P)*P) =\nk*P + r*0 =\nG\nDurch diese Methode wird sichergestellt, dass die Messreihen unterschiedlich sind, auch wenn der gleiche private Schlüssel verwendet wurde.
Constants_120=Q := 2Q = 
Constants_121=Eingabe:
Constants_122=Q := 2Q
Constants_123=Q := Q + P
Constants_124=Q := Q + P = 
Constants_125=Q' := 2Q' = 
Constants_126=(P + R) = (
Constants_127=Q' := Q' + (P + R) = 
Constants_128=P' = (
Constants_129=Q' := Q' + P' = 
Constants_131=Q' = k*(P+R) = Q + S = 
Constants_132=Inverse: -S = (x, -y) = 
Constants_133=Q = Q' - S = Q' + (-S)
Constants_134=Q = (
Constants_135=Q' = (Xq*r²,Yq*r³) = 
Constants_136=\u0304
Constants_137=²
Constants_138=³
Constants_14=Zufälliger initialer EC-Punkt P:\nHierbei wird der Punkt P bei jeder Ausführung neu randomisiert. Dadurch wird es erschwert, eine Korrelation zwischen k*P und den Messreihen herzustellen\n\nDas Prinzip ist folgendermaßen:\nZuerst wird ein zufälliger Punkt R auf der gleichen EC gewählt, der sich von P unterscheidet. Dann wird P durch folgende Formel randomisiert: P' = R+P = P'. Nach der Berechnung von Q' ist das Ergebnis:\nQ' = kP' = k(P + R) =\nk*P + k*R = Q + k*R.\nFür die Inverse eines EC-Punkt gilt: -S = (x,-y). Somit gilt Q = Q' - k*R = Q' + (-kR). P wurde mit dieser Methode verschleiert, wodurch auch die Korrelation zwischen P und den Messreihen verschleiert wurde.
Constants_147=Xq = 
Constants_148=Yq = 
Constants_15=Zufällige isomorphe Kurve:\nEs wird eine zufällige isomorphe Kurve generiert. Die Berechnungen finden mit dieser Kurve statt. Anschließend wird aus dem Ergebnis Q' das Q wiederhergestellt. Eine zufällige isomorphe Kurve kann auch als randomisierter Punkt P verstanden werden.\n\nDas Prinzip ist folgendermaßen:\nZuerst wird ein zufälliges r zwischen 1 und  p-1 generiert. Die Parameter der EC werden daraus folgendermaßen abgeleitet:\na' = r\u2074*a\nb' = r\u2076*b\nP' = (r²*Xp,r³*Yp)\n\nAus diesen Werten wird die isomorphe Kurve abgeleitet: E':= y² = x³ + a'*x + b'\nDanach wird Q' = k*P' = (Xq',Yq') mit der neuen Kurve berechnet. Zum Schluss wird Q aus Q' wiederhergestellt: Q =(r\u207B²*Xq',r\u207B³*Yq')\nDie Korrelation zwischen k*P und den Messreihen wird ebenfalls durch die Randomisierung von P gebrochen.
Constants_16=Zufälliger Parameter k
Constants_17=Zufälliger initialer EC-Punkt P
Constants_18=Zufällige isomorphe Kurve
Constants_19=1. Q = KP at step j the processed point Q depends only on the first bits (kn-2,kn-3; : : : ; kj ) of K.\n\n2. Power consumption will be correlated to specific bit of Q, no correlation will be observed with a point not computed.\n\n3. The 2th most significant bit kn-2 of K can be recovered by computing the correlation between power consumption and any specific bit of the binary representation of 6P.\n\n 4. If kn-1 = 1, 6P is computed as Q[0] = 2*3P = 6P, otherwise by kn-1 = 0, 2*2P will be carried out during the Double operation.\n\n5. We gather many power consumption of computing 6P, and let si be any specific bit of 6P. We use the correlation function: g(t) = Power(si = 0) - Power(si = 1).\n\n6. If 6P is related to simulated correlation function g(t), a peak is observed corresponding to the computation of 6P, otherwise if there is no peak, the second significant bit is 0.\n\n7. The following bits kn-3, kn-4,... kj of K can be recursively recovered in the same way.\n\n8. The countermeasures against DPA are randomizing either the Initial Point P or the scalar multiplier K.
Constants_20=Double and Add Always
Constants_22=Hier wählen Sie den Parameter a der EC
Constants_23=Hier wählen Sie den Parameter b der EC
Constants_24=Ordnung der EC. Die Nummer gibt die Anzahl an EC-Punkten Plus dem Punkt im Unendlichen an.
Constants_25=Wählen Sie den Faktor k für Q = kP
Constants_26=Wählen Sie den EC-Punkt P als initialen Punkt der EC 
Constants_27=Berechnungen durchführen
Constants_28=Die Ordnung des Punktes P
Constants_29=Wählen sie ein Galois-Feld GF(p)
Constants_33=a =
Constants_34=b = 
Constants_35=Wurde mit den Parametern a, b und GF(p) gewählt
Constants_36=Q' := 2Q'
Constants_37=Q' := Q' + P
Constants_38=k in Binärform: 
Constants_39=Input
Constants_42=
Constants_43=Verdoppeln 
Constants_44=Addieren
Constants_46=GF(p) =
Constants_47=y² = x³ + 
Constants_48=x + 
Constants_49=, GF(
Constants_50=a, b muss einen Wert innerhalb von GF(p) haben.
Constants_55=Ordnung des EC-Punktes: 
Constants_59=
Constants_6=Informationen
Constants_60=k in Binärform: 
Constants_61=
Constants_62=Prozess: 
Constants_63=Eingabe:
Constants_64=Q := 2Q
Constants_65=Q := Q + P
Constants_66=Schutzmaßnahme: Parameter k Randomisierung\n\n
Constants_67=Ursprüngliche Eingabe:\n   EC: y² = x³ + 
Constants_68=\n   GF(
Constants_69=), a = 
Constants_7=Wählen Sie zunächst den Modus zur Berechnung der Punkte der EC. Der erste Modus ist der normale "Double and Add"-Algorithmus. "Double and Add Always" ist eine Erweiterung davon, der gegen eine "Simple Power Attack" (SPA) Schutz bietet. Die drei anderen Modi randomisieren verschiedene Parameter, und bieten dadurch Schutz vor DPA. Hierbei wird immer "Double and Add Always" angewandt.\n\nBedienung: Legen Sie zunächst die EC sowie die Punkte auf der EC fest. Wählen Sie den gewünschten Modus und klicken dann auf "Ausführen". Sie können verschiedene Modi ausprobieren.
Constants_70=, b = 
Constants_71=\n   Initialer EC-Punkt P: 
Constants_72=\n   Parameter k: 
Constants_73=\n   k in Binärform: 
Constants_74=\n\nRandomisierung:\n   Zufälliger Faktor r: 
Constants_75=\n   Ordnung von P ord(P): 
Constants_76=\n   k' = k + ord(P)*r = 
Constants_77=\n   k' in Binärdarstellung: 
Constants_78=Zufälliger EC-Punkt R: (
Constants_79=S = k*R = 
Constants_80=R = 
Constants_81=Schutzmaßnahme: Initialen Punkt P Randomisieren\n\n
Constants_82=Ursprüngliche Eingabe:\n   EC: y² = x³ + 
Constants_83=x + 
Constants_84=\n   GF(
Constants_85=), a = 
Constants_86=, b = 
Constants_87=\n   Initialer EC-Punkt P: 
Constants_88=\n   Parameter k: 
Constants_89=\n   k in Binärform: 
Constants_9=Double and Add:\nDieser Algorithmus ist die übliche Art, um auf ECs zu rechnen. Diese Berechnungsweise ist allerdings durch DPA und SPA angreifbar, da sich aus den Strommessungen dierekt erkennen lässt, an welcher Stelle eine Multiplikation und an welcher Stelle eine Muliplikation plus Addition durchgeführt wurde. Dadurch lässt sich die Binärdastellung des privaten Schlüssels unmittelbar rekonstruieren.
Constants_90=\n\nRandomisierung:\n   
Constants_91=Zufälliger EC-Punkt R: (
Constants_92=\n   P + R = 
Constants_93=\n   S = k*R = 
Constants_94=R = 
Constants_95=\n   Q' = k*(P+R) = Q + S
Constants_96=\n   Wenn S = (x,y), dann  -S = (x,-y)
Constants_97=\n   Q = Q' - S = Q' + (-S)
Constants_98=Schutzmaßnahme: Zufällige isomorphe Kurve\n\n
Constants_99=
DPAView_0=In diesem Plug-in werden unterschiedliche Verfahren zum Schutz vor "Differential Power Analysis" (DPA) bei Elliptischen Kurven (EC) vorgestellt.
mode = Modus:
parameter = Kurvenparameter
points = Punkte auf der EC
order_curve = Kurvenordnung
curve = Kurve:
reset = Zurücksetzen
outputtable = Ausgabetabelle
k = k' in Binärform
result = Ausgabe
noprotection0 = Der "Double and Add"-Modus bietet keinen Schutz gegen DPA. Sie können einen anderen Modus wählen, der Parameter randomisiert, wodurch man einen Schutz gegen DPA erhält. Die randomisierten Parameter werden hier auch berechnet.
noprotection1 = Der "Double and Add Always"-Modus bietet keinen Schutz gegen DPA. Sie können einen anderen Modus wählen, der Parameter randomisiert, wodurch man einen Schutz gegen DPA erhält. Die randomisierten Parameter werden hier auch berechnet.
protection = Klicken Sie auf "Ausführen", um die randomisierten Werte zu berechnen. 
Title = Differential Power Analysis (DPA) bei Elliptischen Kurven
DPAView_lblNewLabel_2_text=Zum Plug-in
DPAView_lblNewLabel_3_text=Zum Modus
DPAView_lblNewLabel_4_text=Berechnung der Randomisierung