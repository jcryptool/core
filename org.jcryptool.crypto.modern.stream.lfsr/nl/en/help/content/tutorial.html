<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	  <title>LFSR Cipher</title>
</head>

<body>
	<h1>LFSR Cipher</h1>

  <p>This help file describes LFSR ciphers in general. 
  A description how to use them in JCT can be found in the tutorial to the GUI: <a href="UI/tutorialUI.html">LFSR: How to use this visualization</a>.</p>


	<br>
	<h2>What is an LFSR?</h2>

	<p>A linear feedback shift register (LFSR) is a sequential shift register with combinatorial logic which causes it to pseudo-randomly cycle through a sequence of binary values. The input bit of the shift register is a linear function of its previous state. The most commonly used linear function of single bits is exclusive-or (XOR).<br>
	For most of the general explanations, the authors used the wording from Wikipedia [1].</p>
	<p>The initial value of the LFSR is called the seed, and because the operation of the register is deterministic, the sequence of values produced by the register is completely determined by its current (or previous) state. Likewise, because the register has a finite number of possible states, it must eventually enter a repeating cycle.</p>
	<p> However, an LFSR with a well-chosen feedback function can produce a sequence of bits which appears random and which has a very long cycle. A design modeled after LFSRs often has both speed and area advantages over a functionally equivalent design that does not use LFSRs.</p>


	<br>
	<h2>How do LFSRs work?</h2>

	<p>LFSRs can be implemented in more than one way, but the scope of this document will focus on the most common one &ndash; the Fibonacci implementation.</p>
	<p> The Fibonacci implementation consists of a simple shift register of length m. The bit positions that affect the next state are called the taps. In the diagram below, the tap sequence is [16,14,13,11]. The taps are XOR'd sequentially with the output and then fed back into the leftmost bit.</p>
	<p> A maximal or maximum-length LFSR produces an m-sequence (i.e. cycles through all possible 2^m - 1 states within the shift register except the state where all bits are zero), unless it contains all zeros, in which case it will never change.</p>
	<p> The sequence of numbers generated by an LFSR can be considered a binary numeral
	system, while the tap sequence of an LFSR can be represented as a polynomial mod 2 (finite field arithmetic).
	This means that the coefficients of the polynomial must be 1's or 0's. This is called the
	<b>feedback polynomial</b>. For example, if the taps are at the 16th, 14th, 13th, and 11th bit (as shown), the feedback polynomial is:</p>

	<img src="figure1.png" width="85%"/>

	<p>The 'one' in the polynomial does not correspond to a tap &ndash; it corresponds to the input to the first bit (i.e. x^0, which is equivalent to 1). The powers of the terms represent the tapped bits, counting from the left. The first and last bits are always connected as an input and tap respectively.</p>

	<img src="figure2.png" width="85%"/><br>
	Figure 1: Fibonacci LFSR diagram (Wikipedia)<br><br>



	<h3>LFSR properties</h3>
	<ul>
		<li>The LFSR will only be maximal if the number of taps is even; just 2 or 4 taps can suffice even for extremely long sequences.</li>
		<li>The set of taps must be relatively prime, and share no common divisor to all taps.</li>
		<li>There can be more than one maximal tap sequence for a given LFSR length.</li>
	</ul>


	<h3>Output-stream properties</h3>
	<ul>
		<li>Ones and zeros occur in 'runs'. The output stream 0110100, for example, consists of five runs of lengths 1,2,1,1,2, in order. In one period of a maximal LFSR, 2^(m-1) runs occur (for example, a six bit LFSR will have 32 runs). Exactly 1/2 of these runs are one bit long, 1/4 are two bits long, up to a single run of zeros n-1 bits long, and a single run of ones n bits long. This same property is statistically expected in a truly random sequence.</li>
		<li>LFSR output streams are deterministic. If you know the present state of the register and the positions of the XOR gates (taps), you can predict the next state. This is not possible with truly random events such as nuclear decay.</li>
		<li>The output stream is reversible; an LFSR with mirrored tap sequence will cycle through the states in reverse order.</li>
	</ul>


	<h3>Maximal length tap sequences</h3>

	<p>The choice of which taps to use determines how many values are included in a sequence
	of pseudo-random values before the sequence is repeated. Certain tap settings yield the
	maximal length sequences of 2^(m-1).</p>
	<p> The length of an LFSR sequence before repetition occurs depends on two things: upon the feedback taps and upon the initial state. An LFSR of any given size m (number of registers) is capable of producing every possible state during the period length N = 2^(m-1), but will do so only if proper feedback taps have been chosen (this is then independent of the initial state). Such a sequence is called a maximal length sequence (m-sequence). In cryptography, m-sequences are referred to as pseudo-random sequences.</p>
	<p> When the feedback taps of an LFSR are non-maximal, the length of the generated
	sequence depends also upon the initial state of the LFSR. A non-maximal generator is capable of producing two or more unique sequences (plus the trivial all-zeros one), with the initial state determining which one is produced. Each of these sequences is referred to as a state space of the generator. Together, all possible non-maximal sequences account for all 2^m states of an m-bit state register.</p>
	<p> Properties of non-maximal sequences are generally inferior to those of maximal
	sequences. So the use of non-maximal sequences in real systems is usually avoided in
	favor of their maximal-length counterparts.</p>


	<br>
	<h2>Why are LFSRs useful?</h2>

	<p>LFSRs have long been used as pseudo-random number generators for use in stream
	ciphers (especially in military cryptography) &ndash; due to the ease of construction from simple electromechanical or electronic circuits, long periods, and very uniformly distributed outputs. However, an LFSR is a linear system, leading to fairly easy cryptanalysis. For example, given a stretch of known plaintext and corresponding ciphertext, a stretch of LFSR output used in the system described above can be recovered, and from the output sequence one can construct an LFSR of minimal size by using the Berlekamp-Massey algorithm, which with the known output can be used to simulate the intended receiver to recover the remaining plaintext.</p>
	<p> Important LFSR-based stream ciphers include A5/1 and A5/2 (used in GSM cell phones),
	E0 (used in Bluetooth), and the shrinking generator. The A5/2 cipher has been broken and
	both, A5/1 and E0, have serious weaknesses.</p>


	<br>
	<h2>Examples</h2>

	<p><b>a) 4-bit Fibonacci LFSR</b> from Anne Canteaut [6], section 3.1, page 44:<br>
	<pre>
c = tap = 0011
seed    = 1011
Expected output starts with:         1011 1100 0100 1101 = 0xBC4D
Expected output (after first stage): 1100 0100 1101
	</pre>
	</p>
	
	<p><b>b) 16-bit Fibonacci LFSR</b> from Wikipedia [1], see Figure 1 above:
	<pre>
c = tap = 0000 0000 0010 1101
seed    = 1010 1100 1110 0001 = 0xACE1  (= 1st stage in the LFSR register)

Next stage in the LFSR register (after one clock):
          0101 0110 0111 0000 = 0x5670
  Illustration (how the new stage is created by adding 1 bit at the beginning of the register):
           101 0110 0111 0000 1 = 0xACE1
         0 101 0110 0111 0000   = 0x5670

Expected output starts with: xxxxxxxxxx = 0xyyyy

</pre>
	The tap numbers correspond to a primitive polynomial, so the register cycles through the maximum number of all possible 65535 states (excluding the all-zeroes state). The state 0xACE1 (hexadecimal) will be followed by 0x5670.</p>


	<br>
	<h2>References and where to go to find out more?</h2>

	<ul>
		<li><a target="_blank" href="https://en.wikipedia.org/wiki/Linear-feedback_shift_register">[1] Wikipedia: Linear-feedback shift register</a></li>
		<li><a target="_blank" href="https://www.eetimes.com/document.asp?doc_id=1274550">[2] Tutorial: Linear Feedback Shift Registers (LFSRs)</a></li>
		<li><a target="_blank" href="http://www.maxim-ic.com/appnotes.cfm?appnote_number=1743&CMP=WP-9">[3] Pseudo-Random Number Generation Routine</a></li>
		<li><a target="_blank" href="http://www.crypto-textbook.com/">[4] Christof Paar and Jan Pelzl: "Understanding Cryptography â€“ A Textbook for Students and Practioners", 2010, Chapter 2.3</a></li>		
		<li><a target="_blank" href="https://www.amazon.de/Kryptografie-Entwurf-Einsatz-symmetrischer-Kryptosysteme/dp/3486222139">[5] W. Fumy and H.P. Riess: "Kryptografie", 1994, 2nd edition, Chapters 3.2 and 3.3</a></li>
		<li><a target="_blank" href="https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf">[6] Anne Canteaut: "LFSR-based Stream Ciphers"</a></li>		
	</ul>
<br>	
</body>
</html>
